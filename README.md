# cuda_BitonicSiort
### Cuda Version of Bitonic Sort
- 主要以性能优化为主，通过采用共享内存、算法优化、核函数合并等方式对性能进行了大量优化。
- 程序以长度=1048576的无序序列作为输入，同时以block大小为256的block作为线程组织形式。
- 将无序序列转为步长为block_size的有序序列这一个过程中的多次核函数调用进行合并，通过看原始实现，我们会发现为了达到序列处理的同步性，我们必须以多次核函数调用的方式，利用核函数之间线程同步的特点实现每一轮的交换。但是我们也可以利用block中线程同步的特点，将无序序列转换为步长为block_size的有序序列的过程的多次核函数进行合并。这样可以通过减少kernel调用，从而减少线程分配的代价。
  - 解释：将无序序列转换为步长为block_size的双调序列这一过程移到核函数内部执行，由每一个线程执行整步操作。
  - 经过这一步优化，时间减少为3.01ms.
- 我们用同样的操作，将固定步长下的迭代同样进行合并，当在固定步长下迭代到j=block_size时，我们可以将后面的迭代同样的进行合并；这样同样减少了kernel调用的次数，从而减少线程分配的代价。
  - 经过这一步优化，我们得到算法优化时间为：2.617 ms
- 使用共享内存，存下全局内存中序列的值。由于我们将无序序列处理为步长为block_size的双调序列的过程内置到kernel函数中，因此会在核函数中多次进行不同位置的数据交换。因此，我们可以先将数据预取到共享内存中，在共享内存中对数据进行交换，从而减少访问全局内存的次数。
  - 最后的优化结果：算法执行时间为2.505 ms
- 改变判断顺序，减少逻辑判断次数，通过观察代码可以发现，merge2bitonic_sort中每一次循环都会多判断一次(tid / i) % 2) == 0，因此我们可以将这个条件外移。减少判断次数.
  - 最后优化后，时间减少为2.147 ms
- 尝试进行循环展开，由于多了循环判断，将循环手动展开，但是这一步并没有得到明显优化，因此弃用。

### 最后结果
- 通过选择合适的block_size、合并多次核函数调用过程、使用共享内存存序列数据、调换判断条件减少分支判断的方式，将长度为1048576的序列排序的运行时间从6.223ms减少到2.147ms，速度提升了300%。
